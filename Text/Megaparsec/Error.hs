-- |
-- Module      :  Text.Megaparsec.Error
-- Copyright   :  © 2015–2017 Megaparsec contributors
-- License     :  FreeBSD
--
-- Maintainer  :  Mark Karpov <markkarpov92@gmail.com>
-- Stability   :  experimental
-- Portability :  portable
--
-- Parse errors. Current version of Megaparsec supports well-typed errors
-- instead of 'String'-based ones. This gives a lot of flexibility in
-- describing what exactly went wrong as well as a way to return arbitrary
-- data in case of failure.
--
-- You probably do not want to import this module directly because
-- "Text.Megaparsec" re-exports it anyway.


{-# LANGUAGE CPP                 #-}
{-# LANGUAGE DeriveDataTypeable  #-}
{-# LANGUAGE DeriveFunctor       #-}
{-# LANGUAGE DeriveGeneric       #-}
{-# LANGUAGE FlexibleContexts    #-}
{-# LANGUAGE FlexibleInstances   #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Text.Megaparsec.Error
  ( ErrorItem (..)
  , ErrorFancy (..)
  , ParseError (..)
  , errorPos
  , ShowToken (..)
  , ShowErrorComponent (..)
  , parseErrorPretty
  , parseErrorPrettyWithLine
  , parseErrorPrettyWithStreamContext
  , sourcePosStackPretty
  , parseErrorTextPretty )
where

import Control.DeepSeq
import Control.Exception
import Data.Char (chr)
import Data.Data (Data)
import Data.List (intercalate)
import Data.List.NonEmpty (NonEmpty (..))
import Data.Maybe (fromJust, fromMaybe, isNothing)
import Data.Proxy
import Data.Semigroup
import Data.Set (Set)
import Data.Typeable (Typeable)
import Data.Void
import Data.Word (Word8)
import GHC.Generics
import Prelude hiding (concat)
import Text.Megaparsec.Pos
import Text.Megaparsec.Stream 
import qualified Data.List.NonEmpty as NE
import qualified Data.Set           as E
import Debug.Trace
#if !MIN_VERSION_base(4,8,0)
import Control.Applicative
#endif

-- | Data type that is used to represent “unexpected\/expected” items in
-- 'ParseError'. The data type is parametrized over the token type @t@.
--
-- @since 5.0.0

data ErrorItem t
  = Tokens (NonEmpty t)      -- ^ Non-empty stream of tokens
  | Label (NonEmpty Char)    -- ^ Label (cannot be empty)
  | EndOfInput               -- ^ End of input
  deriving (Show, Read, Eq, Ord, Data, Typeable, Generic, Functor)

instance NFData t => NFData (ErrorItem t)

-- | Additional error data, extendable by user. When no custom data is
-- necessary, the type is typically indexed by 'Void' to “cancel” the
-- 'ErrorCustom' constructor.
--
-- @since 6.0.0

data ErrorFancy e
  = ErrorFail String
    -- ^ 'fail' has been used in parser monad
  | ErrorIndentation Ordering Pos Pos
    -- ^ Incorrect indentation error: desired ordering between reference
    -- level and actual level, reference indentation level, actual
    -- indentation level
  | ErrorCustom e
    -- ^ Custom error data, can be conveniently disabled by indexing
    -- 'ErrorFancy' by 'Void'
  deriving (Show, Read, Eq, Ord, Data, Typeable, Generic, Functor)

instance NFData a => NFData (ErrorFancy a) where
  rnf (ErrorFail str) = rnf str
  rnf (ErrorIndentation ord ref act) = ord `seq` rnf ref `seq` rnf act
  rnf (ErrorCustom a) = rnf a

-- | 'ParseError' represents… parse errors. The data type is parametrized
-- over the token type @t@ and the custom data @e@.
--
-- Note that the stack of source positions contains current position as its
-- head, and the rest of positions allows to track full sequence of include
-- files with topmost source file at the end of the list.
--
-- 'Semigroup' and 'Monoid' instances of the data type allow to merge parse
-- errors from different branches of parsing. When merging two
-- 'ParseError's, the longest match is preferred; if positions are the same,
-- custom data sets and collections of message items are combined. Note that
-- fancy errors take precedence over trivial errors in merging.
--
-- @since 6.0.0

data ParseError t e
  = TrivialError (NonEmpty SourcePos) (Maybe (ErrorItem t)) (Set (ErrorItem t))
    -- ^ Trivial errors, generated by Megaparsec's machinery. The data
    -- constructor includes the stack of source positions, unexpected token
    -- (if any), and expected tokens.
  | FancyError (NonEmpty SourcePos) (Set (ErrorFancy e))
    -- ^ Fancy, custom errors.
  deriving (Show, Read, Eq, Data, Typeable, Generic)

instance (NFData t, NFData e) => NFData (ParseError t e)

instance (Ord t, Ord e) => Semigroup (ParseError t e) where
  (<>) = mergeError
  {-# INLINE (<>) #-}

instance (Ord t, Ord e) => Monoid (ParseError t e) where
  mempty  = TrivialError (initialPos "" :| []) Nothing E.empty
  mappend = (<>)
  {-# INLINE mappend #-}

instance ( Show t
         , Ord t
         , ShowToken t
         , Typeable t
         , Show e
         , ShowErrorComponent e
         , Typeable e )
  => Exception (ParseError t e) where
#if MIN_VERSION_base(4,8,0)
  displayException = parseErrorPretty
#endif

-- | Get position of given 'ParseError'.
--
-- @since 6.0.0

errorPos :: ParseError t e -> NonEmpty SourcePos
errorPos (TrivialError p _ _) = p
errorPos (FancyError   p _)   = p

-- | Merge two error data structures into one joining their collections of
-- message items and preferring the longest match. In other words, earlier
-- error message is discarded. This may seem counter-intuitive, but
-- 'mergeError' is only used to merge error messages of alternative branches
-- of parsing and in this case longest match should be preferred.

mergeError :: (Ord t, Ord e)
  => ParseError t e
  -> ParseError t e
  -> ParseError t e
mergeError e1 e2 =
  case errorPos e1 `compare` errorPos e2 of
    LT -> e2
    EQ ->
      case (e1, e2) of
        (TrivialError s1 u1 p1, TrivialError _ u2 p2) ->
          TrivialError s1 (n u1 u2) (E.union p1 p2)
        (FancyError {}, TrivialError {}) -> e1
        (TrivialError {}, FancyError {}) -> e2
        (FancyError s1 x1, FancyError _ x2) ->
          FancyError s1 (E.union x1 x2)
    GT -> e1
  where
    -- NOTE The logic behind this merging is that since we only combine
    -- parse errors that happen at exactly the same position, all the
    -- unexpected items will be prefixes of input stream at that position or
    -- labels referring to the same thing. Our aim here is to choose the
    -- longest prefix (merging with labels and end of input is somewhat
    -- arbitrary, but is necessary because otherwise we can't make
    -- ParseError lawful Monoid and have nice parse errors at the same
    -- time).
    n Nothing  Nothing = Nothing
    n (Just x) Nothing = Just x
    n Nothing (Just y) = Just y
    n (Just x) (Just y) = Just (max x y)
{-# INLINE mergeError #-}

-- | Type class 'ShowToken' includes methods that allow to pretty-print
-- single token as well as stream of tokens. This is used for rendering of
-- error messages.
--
-- @since 5.0.0

class ShowToken a where

  -- | Pretty-print non-empty stream of tokens. This function is also used
  -- to print single tokens (represented as singleton lists).

  showTokens :: NonEmpty a -> String

instance ShowToken Char where
  showTokens = stringPretty

instance ShowToken Word8 where
  showTokens = stringPretty . fmap (chr . fromIntegral)

-- | The type class defines how to print custom data component of
-- 'ParseError'.
--
-- @since 5.0.0

class Ord a => ShowErrorComponent a where

  -- | Pretty-print custom data component of 'ParseError'.

  showErrorComponent :: a -> String

instance (Ord t, ShowToken t) => ShowErrorComponent (ErrorItem t) where
  showErrorComponent (Tokens   ts) = showTokens ts
  showErrorComponent (Label label) = NE.toList label
  showErrorComponent EndOfInput    = "end of input"

instance ShowErrorComponent e => ShowErrorComponent (ErrorFancy e) where
  showErrorComponent (ErrorFail msg) = msg
  showErrorComponent (ErrorIndentation ord ref actual) =
    "incorrect indentation (got " <> show (unPos actual) <>
    ", should be " <> p <> show (unPos ref) <> ")"
    where
      p = case ord of
            LT -> "less than "
            EQ -> "equal to "
            GT -> "greater than "
  showErrorComponent (ErrorCustom a) = showErrorComponent a

instance ShowErrorComponent Void where
  showErrorComponent = absurd

-- | Pretty-print a 'ParseError'. The rendered 'String' always ends with a
-- newline.
--
-- @since 5.0.0

parseErrorPretty
  :: ( Ord t
     , ShowToken t
     , ShowErrorComponent e )
  => ParseError t e    -- ^ Parse error to render
  -> String            -- ^ Result of rendering
parseErrorPretty e =
  sourcePosStackPretty (errorPos e) <> ":\n" <> parseErrorTextPretty e


-- | Pretty-print a 'ParseError' and display the line on which the parse error
-- occurred. The rendered 'String' always ends with a newline.
--
-- Assumes that the stream tokens can be coerced to an @Int@ and that the value
-- integer value @10@ corresponds to a new-line character.
--
-- @since 6.0.0

parseErrorPrettyWithLine
  :: ( Enum (Token s)
     , Ord t
     , ShowToken t
     , ShowToken (Token s)
     , ShowErrorComponent e
     , Stream s )
  => s              -- ^ Original input stream
  -> ParseError t e -- ^ Parse error to render
  -> String         -- ^ Result of rendering
parseErrorPrettyWithLine stream = parseErrorPrettyWithStreamContext stream (mkPos 80) isNotNewLine
  where
    isNotNewLine x = fromEnum x /= 10

-- | Pretty-print a 'ParseError' and display the line on which the parse error
-- occurred. The rendered 'String' always ends with a newline.
--
-- @since 6.0.0

parseErrorPrettyWithStreamContext
  :: forall e s t.
     ( Ord t
     , ShowToken t
     , ShowToken (Token s)
     , ShowErrorComponent e
     , Stream s )
  => s                 -- ^ Original input stream
  -> Pos               -- ^ Maximum number of Tokens to display
  -> (Token s -> Bool) -- ^ Pruning function
  -> ParseError t e    -- ^ Parse error to render
  -> String            -- ^ Result of rendering
parseErrorPrettyWithStreamContext stream n f e = mconcat messageComponents
  where
    positions     = errorPos e
    errorPosition = NE.last positions
    (pointer, errorContext) = getStreamContext stream n f errorPosition
    lineMessage   = renderLineMessage errorContext errorPosition pointer
    messageComponents =
      [ sourcePosStackPretty positions
      , ":\n"
      , lineMessage 
      , parseErrorTextPretty e ] 


-- |
-- Retreives the collection of tokens around where
getStreamContext
  :: forall s. (Stream s, ShowToken (Token s))
  => s
  -> Pos               -- ^ Maximum number of tokens to return
  -> (Token s -> Bool) -- ^ A pruning function to further truncate the returned tokens
  -> SourcePos         -- ^ Where in the stream the parse error occured
  -> (Int, [Token s])  -- ^ The specified tokens surrounding the parse error and which token of these was unexpected
getStreamContext stream maxTokens f errPos = (length prunnedPrefix, prunnedPrefix <> prunnedSuffix)
  where
    pxy = Proxy :: Proxy s
    (     _, stream'  ) = fromJust $ takeN_ windowOpen stream
    (prefix, stream'' ) = fromJust $ takeN_ windowPrefix stream'
    suffix = maybe [] (chunkToTokens pxy . fst) $ takeN_ windowSuffix stream''
    (prunnedPrefix, dropSuffix) =
      case reverse $ chunkToTokens pxy prefix of
        []   -> ([], False)
        x:xs -> (reverse $ x : (takeWhile f xs), not $ f x)
                        
    prunnedSuffix
      | dropSuffix = []
      | otherwise  = takeWhile f suffix
    streamIndex  = unPos $ totalTokens errPos
    numTokens    = unPos maxTokens
    radius       = numTokens `div` 2
    radius'      = numTokens - radius -- used for handling odd maxTokens values
    windowOpen   = max 0 (streamIndex - radius')
    windowPrefix = min streamIndex radius'
    windowSuffix = radius


-- | General algorithm for rendering a collection of 'ShowToken' values to a
-- String. Underlines the unexpected token in the output string. 
renderLineMessage
  :: ShowToken t
  => [t]         -- ^ Collection of tokens, one of which is unexpected
  -> SourcePos   -- ^ Parse error position
  -> Int         -- ^ Index of the unexpected token 
  -> String
renderLineMessage ts p arrow = unlines [ paddingLine, contextLine, pointingLine ]
  where
    paddingLine   = mconcat [padding, "|"]
    contextLine   = mconcat [" ", lineNumberStr, " | ", renderedTokens]
    pointingLine  = mconcat [padding, "| ", pointingLineSpaces, pointingLinePointer]

    lineNumberStr = show $ unPos linePos
    padLength = length lineNumberStr + 2
    padding = replicate padLength ' '
    linePos = sourceLine p

    pointingLineSpaces  = replicate (max 1 (leadingLength - 1)) ' '
    pointingLinePointer = replicate pointingLinePointLen '^'

    -- This is rather complicated, but generalized rendering algorithm.

    renderedTokens =
        case ts of
          []   -> ""
          x:xs -> showTokens $ x:|xs

    leadingLength =
      case take (arrow - 1) ts of
        []   -> 0
        x:xs -> length . showTokens $ x:|xs

    trailingLength =
      case drop arrow ts of
        []   -> 0
        x:xs -> length . showTokens $ x:|xs

    pointingLinePointLen =
      case (leadingLength, trailingLength) of
        (0,0) -> length renderedTokens
        (0,n) -> case drop (arrow - 1) ts of
                   []   -> 0
                   x:xs -> let len = length . showTokens $ x:|xs
                           in  len - n
        (n,_) -> case take arrow ts of
                   []   -> 0
                   x:xs -> let len = length . showTokens $ x:|xs
                           in  len - n

-- | Pretty-print a stack of source positions.
--
-- @since 5.0.0

sourcePosStackPretty :: NonEmpty SourcePos -> String
sourcePosStackPretty ms = mconcat (f <$> rest) <> sourcePosPretty pos
  where
    (pos :| rest') = ms
    rest           = reverse rest'
    f p = "in file included from " <> sourcePosPretty p <> ",\n"

-- | Pretty-print a textual part of a 'ParseError', that is, everything
-- except stack of source positions. The rendered staring always ends with a
-- new line.
--
-- @since 5.1.0

parseErrorTextPretty
  :: ( Ord t
     , ShowToken t
     , ShowErrorComponent e )
  => ParseError t e    -- ^ Parse error to render
  -> String            -- ^ Result of rendering
parseErrorTextPretty (TrivialError _ us ps) =
  if isNothing us && E.null ps
    then "unknown parse error\n"
    else messageItemsPretty "unexpected " (maybe E.empty E.singleton us) <>
         messageItemsPretty "expecting "  ps
parseErrorTextPretty (FancyError _ xs) =
  if E.null xs
    then "unknown fancy parse error\n"
    else unlines (showErrorComponent <$> E.toAscList xs)

----------------------------------------------------------------------------
-- Helpers

-- | @stringPretty s@ returns pretty representation of string @s@. This is
-- used when printing string tokens in error messages.

stringPretty :: NonEmpty Char -> String
stringPretty (x:|[])      = charPretty x
stringPretty ('\r':|"\n") = "crlf newline"
stringPretty xs           = "\"" <> concatMap f (NE.toList xs) <> "\""
  where
    f ch =
      case charPretty' ch of
        Nothing     -> [ch]
        Just pretty -> "<" <> pretty <> ">"

-- | @charPretty ch@ returns user-friendly string representation of given
-- character @ch@, suitable for using in error messages.

charPretty :: Char -> String
charPretty ' ' = "space"
charPretty ch = fromMaybe ("'" <> [ch] <> "'") (charPretty' ch)

-- | If the given character has a pretty representation, return that,
-- otherwise 'Nothing'. This is an internal helper.

charPretty' :: Char -> Maybe String
charPretty' '\NUL' = pure "null"
charPretty' '\SOH' = pure "start of heading"
charPretty' '\STX' = pure "start of text"
charPretty' '\ETX' = pure "end of text"
charPretty' '\EOT' = pure "end of transmission"
charPretty' '\ENQ' = pure "enquiry"
charPretty' '\ACK' = pure "acknowledge"
charPretty' '\BEL' = pure "bell"
charPretty' '\BS'  = pure "backspace"
charPretty' '\t'   = pure "tab"
charPretty' '\n'   = pure "newline"
charPretty' '\v'   = pure "vertical tab"
charPretty' '\f'   = pure "form feed"
charPretty' '\r'   = pure "carriage return"
charPretty' '\SO'  = pure "shift out"
charPretty' '\SI'  = pure "shift in"
charPretty' '\DLE' = pure "data link escape"
charPretty' '\DC1' = pure "device control one"
charPretty' '\DC2' = pure "device control two"
charPretty' '\DC3' = pure "device control three"
charPretty' '\DC4' = pure "device control four"
charPretty' '\NAK' = pure "negative acknowledge"
charPretty' '\SYN' = pure "synchronous idle"
charPretty' '\ETB' = pure "end of transmission block"
charPretty' '\CAN' = pure "cancel"
charPretty' '\EM'  = pure "end of medium"
charPretty' '\SUB' = pure "substitute"
charPretty' '\ESC' = pure "escape"
charPretty' '\FS'  = pure "file separator"
charPretty' '\GS'  = pure "group separator"
charPretty' '\RS'  = pure "record separator"
charPretty' '\US'  = pure "unit separator"
charPretty' '\DEL' = pure "delete"
charPretty' '\160' = pure "non-breaking space"
charPretty' _      = Nothing

-- | Transforms a list of error messages into their textual representation.

messageItemsPretty :: ShowErrorComponent a
  => String            -- ^ Prefix to prepend
  -> Set a             -- ^ Collection of messages
  -> String            -- ^ Result of rendering
messageItemsPretty prefix ts
  | E.null ts = ""
  | otherwise =
    let f = orList . NE.fromList . E.toAscList . E.map showErrorComponent
    in prefix <> f ts <> "\n"

-- | Print a pretty list where items are separated with commas and the word
-- “or” according to the rules of English punctuation.

orList :: NonEmpty String -> String
orList (x:|[])  = x
orList (x:|[y]) = x <> " or " <> y
orList xs       = intercalate ", " (NE.init xs) <> ", or " <> NE.last xs
